**************
Code Structure
**************

This is an overview the internal structure of the code, catering to those who
want to add functionality or support reading a new format.

Baseband's source code is located under the :file:`baseband` directory.  The
Python files in this folder link baseband and astropy together, enable the
Astropy test system, or are auto-generated by :file:`setup.py`.  Subfolders in 
:file:`baseband` include

- :file:`baseband/data` - stores data snippets for testing and tutorials
- :file:`baseband/helpers` - helper functions
- :file:`baseband/tests` - baseband tests run by the Astropy testing framework
- :file:`baseband/vlbi_base` - stores common to all readers

All other folders store the classes needed to read a particular file format, 
such as dada, mark5b, or vdif.  These are children of classes in 
:file:`vlbi_base`, and similar inheritance should be used when including a 
reader for a new format.  To understand how :file:`vlbi_base` is connected to
the readers, we consider what happens when a vdif file is read.

.. _cs_vdif_intro:

VDIF Reader
===========

To read in binary mode the sample VDIF file included with baseband, we use the
``vdif`` class 

::

>>> from baseband import vdif
>>> from baseband.data import SAMPLE_VDIF
>>> fh = vdif.open(SAMPLE_VDIF, 'rs')
>>> d = fh.read()

(``SAMPLE_VDIF`` is simply the ``str`` :file:`baseband/data/sample.vdif`.)

:func:`vdif.open() <baseband.vdif.open>` is the only function or class in the ``vdif`` module 
directly accessible from :class:`~baseband.vdif` as, in lieu of troubeshooting, 
it is the only thing users should access.  The functions and classes used by
:func:`vdif.open() <baseband.vdif.open>` are in

- :file:`baseband/vdif/base.py` - defines :func:`vdif.open() <baseband.vdif.open>`, 
  stream reader and writer classes
- :file:`baseband/vdif/frame.py` - contains VDIF data storage container class
- :file:`baseband/vdif/header.py` - contains VDIF header readers
- :file:`baseband/vdif/payload.py` - contains VDIF data readers
- :file:`baseband/vdif/tests/` - defines routines to test :file:`baseband/vdif`

This code structure is repeated for all other supported file formats, and ought
to be followed when creating custom file support.

.. _cs_vdif_base_read:

VDIF Stream Reader Classes
--------------------------

:func:`vdif.open() <baseband.vdif.open>` itself calls 
:class:`~baseband.vdif.base.VDIFFileReader` and 
:class:`~baseband.vdif.VDIFStreamReader`; the call to it in the
:ref:`code block <cs_vdif_intro>` at the start of the section is equivalent to::

    >>> import io
    >>> name = io.open(SAMPLE_VDIF, 'rb')
    >>> fhr = vdif.base.VDIFFileReader(name)
    >>> fh = vdif.base.VDIFStreamReader(fhr)

:class:`~baseband.vdif.base.VDIFFileReader` is a subclass of 
:class:`io.BufferedReader` that includes the
:meth:`~baseband.vdif.base.VDIFFileReader.read_frame()`,
:meth:`~baseband.vdif.base.VDIFFileReader.read_frameset()` and
:meth:`~baseband.vdif.base.VDIFFileReader.find_header()` methods.  The former
two simply call :meth:`VDIFFrame.fromdata() <baseband.vdif.frame.VDIFFrame.fromdata>` 
and :meth:`VDIFFrameSet.fromdata() <baseband.vdif.frame.VDIFFrameSet.fromdata>`, 
respectively.  The latter finds the next (or previous, if ``forward=False`` is 
passed to it) header from the file pointer's current position.

:class:`~baseband.vdif.VDIFStreamReader` is not a subclass of 
:class:`~baseband.vdif.base.VDIFFileReader`, but takes in a :class:`~!baseband.vdif.base.VDIFStreamReader`
object during class instance initialization.  Upon initialization, the first
header of the file is read using :class:`~baseband.vdif.header.VDIFHeader`, 
and the number of threads determined by reading the first frameset using 
:meth:`VDIFFileReader.read_frameset() <baseband.vdif.base.VDIFFileReader.read_frameset>`
and counting the number of frames found.  The payload can then be read by 
calling :meth:`VDIFStreamReader.read() <baseband.vdif.base.VDIFStreamReader.read>`,
which returns a :class:`numpy.ndarray` whose indices are counts and threads::

    >>> data = fh.read()
    >>> data.shape
    (40000, 8)

:meth:`~baseband.vdif.VDIFStreamReader.read` calls private method
:meth:`~baseband.vdif.VDIFStreamReader._read_frame_set`, which in turn
calls :meth:`VDIFFileReader.read_frameset() <!baseband.vdif.base.VDIFFileReader.read_frameset>`
to read framesets.  For the trivial case above of reading an entire file, we 
can manually replicate :meth:`~!baseband.vdif.base.VDIFStreamReader.read`'s 
behaviour with::

    >>> import numpy as np
    >>> # Read in file.
    >>> name = io.open(SAMPLE_VDIF, 'rb')
    >>> fb = vdif.base.VDIFFileReader(name)
    >>> # Determine file length in bytes.
    >>> fb_bytesize = fb.seek(0, 2)
    >>> fb.seek(0)
    0
    >>> # Determine number of threads in frameset and number of framesets in file.  
    >>> # Functionally identical to thread finder in VDIFStreamReader.__init__().
    >>> first_frameset = fb.read_frameset(None)
    >>> thread_ids = [fr['thread_id'] for fr in first_frameset.frames]
    >>> nthread = len(thread_ids)
    >>> nframe = fb_bytesize // fb.tell()
    >>> # Get number of samples per frameset.
    >>> samp_per_fset = first_frameset.header0.samples_per_frame
    >>> # Define output ndarray (number of Fourier channels nchan = 1).
    >>> out = np.empty((nthread, samp_per_fset*nframe, 1), \
    ...                 dtype=first_frameset.dtype).transpose(1, 0, 2)
    >>> # Simpler version of the "while count > 0:" loop in VDIFStreamReader.read().
    >>> fb.seek(0)
    0
    >>> for i in range(nframe):
    ...     cframe = fb.read_frameset(thread_ids)
    ...     out[i*samp_per_fset:(i + 1)*samp_per_fset] = \
    ...            cframe.data.transpose(1, 0, 2)
    >>> # Check that output is the same as fh.read() from above.
    >>> np.array_equal(out.squeeze(), data)
    True

:class:`~baseband.vdif.base.VDIFFileReader`, however, has an ``offset`` data 
pointer that increments in units of samples. (As discussed below, it works 
directly on the data stream, and is **not** a file pointer!  The original byte
pointer is available through ``VDIFStreamReader.fh_raw`` and functions 
indepently from ``offset``.)  It controls where 
:meth:`~!baseband.vdif.base.VDIFStreamReader.read` starts reading data, and can 
be used to read subsections of the data even if we start and end in the middle
of framesets::

    >>> # Set offset pointer to halfway into the first frame
    >>> fh.seek(fh.samples_per_frame // 2)
    10000
    >>> data_m = fh.read(fh.samples_per_frame)  # Read 1 frame worth of samples
    >>> data_m.shape
    (20000, 8)
    >>> # Check that first sample read is from middle of first frameset
    >>> np.array_equal(data_m[0], data[fh.samples_per_frame // 2])
    True

:class:`~baseband.vdif.VDIFStreamReader` is a subclass of
:class:`~baseband.vdif.base.VDIFStreamBase` and 
:class:`~baseband.vlbi_base.base.VLBIStreamReaderBase`.
:class:`~baseband.vdif.base.VDIFStreamBase` is subclassed from
:class:`~baseband.vlbi_base.base.VLBIStreamBase`, and only appends private
methods for printing class information to screen and calculating times for 
headers.  The ``offset`` data pointer, which also has the ability to
increment in time units, is inherited from the :mod:`~baseband.vlbi_base` 
classes.

.. _cs_vdif_header:

VDIF Header Module
------------------

When :class:`~baseband.vdif.VDIFStreamReader` is initialized, it calls classes
from :mod:`baseband.vdif.header` to read the header, specifically by passing the
:class:`~baseband.vdif.VDIFFileReader` instance into
:meth:`VDIFHeader.fromfile() <baseband.vdif.VDIFHeader.fromfile>`.  We can
reproduce this behaviour with::

    >>> name = io.open(SAMPLE_VDIF, 'rb')
    >>> fhr = vdif.base.VDIFFileReader(name)
    >>> header = vdif.header.VDIFHeader.fromfile(name)
    >>> header.ref_epoch  # Number of 6-month periods after Jan 1, 2000.
    28

Perhaps unintuitively, the ``type`` of header is 
:class:`~baseband.vdif.header.VDIFHeader3`::

    >>> isinstance(header, vdif.header.VDIFHeader3)
    True

Modern VDIF headers are composed of 8 "words", each 4 bytes long.  Words 0 - 3
have fixed meanings, but words 4 - 7 hold optional "extended user data" that
can be telescope or experiment-specific.  The layout of this data is specified 
by its "extended-data version" (EDV) in word 4, byte 3, and registered EDV 
formats are found on the `VDIF specification site <http://www.vlbi.org/vdif/>`_.
Baseband pairs each EDV format with its own header class 
(:class:`~baseband.vdif.header.VDIFHeader3` is for ``EDV = 0x03``, or NRAO data), 
and currently accommodates EDVs 1 through 4, as well as the 4-word legacy VDIF 
header and Mark 5B headers transformed into VDIF (``EDV = 0xab``)

VDIF Writer
===========
